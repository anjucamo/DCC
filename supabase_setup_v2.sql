-- 1. TIPOS PERSONALIZADOS
-- Primero, nos aseguramos de que los tipos de rol y estado existan.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_role') THEN
        CREATE TYPE public.app_role AS ENUM ('asesor', 'back', 'admin');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'sale_status') THEN
        CREATE TYPE public.sale_status AS ENUM ('PENDIENTE', 'APROBADO', 'RECHAZADO');
    END IF;
END$$;


-- 2. TABLA DE PERFILES (Profiles)
-- Esta tabla almacenará datos públicos de los usuarios.
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  role app_role DEFAULT 'asesor'::app_role,
  sala TEXT
);

-- Comentarios para la tabla de perfiles.
COMMENT ON TABLE public.profiles IS 'Public profile information for each user.';
COMMENT ON COLUMN public.profiles.id IS 'References auth.users.id';


-- 3. SEGURIDAD PARA LA TABLA DE PERFILES
-- Habilitar Row Level Security (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Política: Los usuarios pueden ver todos los perfiles.
-- (Puedes restringirlo a solo ver su propio perfil si lo prefieres, cambiando 'USING (true)' a 'USING (auth.uid() = id)')
CREATE POLICY "Allow users to view all profiles"
ON public.profiles FOR SELECT
TO authenticated
USING (true);

-- Política: Los usuarios pueden actualizar su propio perfil.
CREATE POLICY "Allow users to update their own profile"
ON public.profiles FOR UPDATE
TO authenticated
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);


-- 4. FUNCIÓN Y TRIGGER PARA CREAR PERFILES AUTOMÁTICAMENTE
-- Esta función se ejecuta cada vez que se crea un nuevo usuario en `auth.users`
-- e inserta una fila correspondiente en `public.profiles`.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, role)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', (new.raw_user_meta_data->>'role')::app_role);
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- El trigger que llama a la función anterior después de cada inserción en `auth.users`.
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- 5. TABLA DE VENTAS (Sales)
-- Revisa que tu tabla `ventas` tenga una columna para el `user_id`.
-- Si ya existe, puedes adaptar este script. Si no, esta es una buena estructura.
CREATE TABLE public.ventas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  asesor TEXT,
  sala TEXT,
  fecha DATE NOT NULL,
  cliente TEXT,
  numero_aportar TEXT,
  cedula TEXT,
  estado sale_status DEFAULT 'PENDIENTE'::sale_status,
  monto NUMERIC,
  crudo JSONB,
  obs_hist TEXT[]
);

-- Comentarios para la tabla de ventas
COMMENT ON TABLE public.ventas IS 'Sales records for the application.';
COMMENT ON COLUMN public.ventas.user_id IS 'Foreign key to the user who created the sale.';


-- 6. SEGURIDAD PARA LA TABLA DE VENTAS
-- Habilitar Row Level Security (RLS)
ALTER TABLE public.ventas ENABLE ROW LEVEL SECURITY;

-- Política de INSERCIÓN: Cualquier usuario autenticado puede crear una venta.
CREATE POLICY "Allow authenticated users to insert sales"
ON public.ventas FOR INSERT
TO authenticated
WITH CHECK (true);

-- Política de SELECCIÓN (Lectura):
-- Los asesores solo ven sus propias ventas.
-- Los roles 'back' y 'admin' ven todas las ventas.
CREATE POLICY "Allow users to view sales based on role"
ON public.ventas FOR SELECT
TO authenticated
USING (
  (get_my_claim('role')::text = 'asesor' AND auth.uid() = user_id) OR
  (get_my_claim('role')::text IN ('back', 'admin'))
);

-- Política de ACTUALIZACIÓN:
-- Los asesores pueden editar sus ventas si están en estado 'PENDIENTE'.
-- Los roles 'back' y 'admin' pueden editar cualquier venta.
CREATE POLICY "Allow users to update sales based on role and status"
ON public.ventas FOR UPDATE
TO authenticated
USING (
  (get_my_claim('role')::text = 'asesor' AND auth.uid() = user_id AND estado = 'PENDIENTE'::sale_status) OR
  (get_my_claim('role')::text IN ('back', 'admin'))
)
WITH CHECK (
  (get_my_claim('role')::text = 'asesor' AND auth.uid() = user_id AND estado = 'PENDIENTE'::sale_status) OR
  (get_my_claim('role')::text IN ('back', 'admin'))
);

-- Política de BORRADO:
-- Los asesores NO pueden borrar ventas. (Se puede cambiar si es necesario)
-- Solo los roles 'back' y 'admin' pueden borrar ventas.
CREATE POLICY "Allow admins and back office to delete sales"
ON public.ventas FOR DELETE
TO authenticated
USING (get_my_claim('role')::text IN ('back', 'admin'));


-- 7. FUNCIÓN AUXILIAR PARA OBTENER 'claims' del JWT
-- Esta función ayuda a leer el 'rol' del usuario directamente desde su token de sesión.
-- Es necesaria para las políticas de seguridad basadas en roles.
CREATE OR REPLACE FUNCTION public.get_my_claim(claim TEXT)
RETURNS JSONB AS $$
BEGIN
  RETURN (
    SELECT coalesce(nullif(current_setting('request.jwt.claims', true), '')::jsonb -> claim, null)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
